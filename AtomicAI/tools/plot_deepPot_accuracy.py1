import pandas as pd
import numpy as np

import numpy as np
import pandas as pd
import sys, os
from os import listdir
from os.path import isfile, join
from sklearn.metrics import r2_score

import plotly.express as px
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import glob
import subprocess

#from plotly.offline import init_notebook_mode, iplot

#init_notebook_mode(connected=True)

def plot_deepPot_accuracy():

    # Specify the directory where you want to check for the file
    directory_path = './'

    # Check if the file exists in the specified directory
    file_force = os.path.join(directory_path, 'results.f.out')
    file_energy = os.path.join(directory_path, 'results.e.out')
    for file_ in [file_force, file_energy]:
        if not os.path.exists(file_):
            print(
                f"The file 'results.f.out' does not exist in the directory: {directory_path}"
            )
            exit()

    # Specify the directory where you want to check for the file
    directory_path = '../00.data/validation_data/'

    # Check if the file exists in the specified directory
    atoms = os.path.join(directory_path, 'type.raw')
    atomic_indices = os.path.join(directory_path, 'type_map.raw')
    for file_ in [file_force, file_energy]:
        if not os.path.exists(file_):
            print(
                f"The file 'type.raw' does not exist in the directory: {directory_path}"
            )
            exit()

    # Define the directory path
    #directory_path = "./out"
    directory_path = '../00.data/validation_data/'

    # File paths
    #atomic_indices_file = os.path.join(directory_path, 'type.raw')
    #atoms_file = os.path.join(directory_path, 'type_map.raw')
    atomic_indices_file = f"{directory_path}/type.raw"
    atoms_file = f"{directory_path}/type_map.raw"

    # Initialize a dictionary to store the mapping
    atom_index_map = {}

    # Read atoms and indices from files and create the mapping
    with open(atoms_file, 'r') as atoms_f, open(atomic_indices_file,
                                                'r') as indices_f:
        atoms_ = atoms_f.read().splitlines()
        indices = indices_f.read().splitlines()

        # Create the mapping of indices to atoms
        atom_index_map = {index: atom for index, atom in zip(indices, atoms_)}
    print(atoms_)
    # Create a dictionary to map indices to atoms
    index_atom_map = {str(i): atom for i, atom in enumerate(atoms_)}

    # Replace indices with corresponding atoms
    atoms = [index_atom_map[index] for index in indices]  # atoms in a single frame

    # Read forces and energues
    data_f = pd.read_csv(file_force, header=None, sep=' ',
                         skiprows=1) #.iloc[:len(atoms) * 10]
    data_e = pd.read_csv(file_energy, header=None, sep=' ',
                         skiprows=1)  #.astype(float)

    #data_fx data_fy data_fz pred_fx pred_fy pred_fz
    x_name = [
        'DFT F<sub>x</sub> (eV/Å)', 'DFT F<sub>y</sub> (eV/Å)',
        'DFT F<sub>z</sub> (eV/Å)'
    ]
    y_name = [
        'DLP F<sub>x</sub> (eV/Å)', 'DLP F<sub>y</sub> (eV/Å)',
        'DLP F<sub>z</sub> (eV/Å)'
    ]
    legends = ['F<sub>x</sub>', 'F<sub>y</sub>', 'F<sub>z</sub>']

    data_f.columns = x_name + y_name
    data_e.columns = ['DFT Energy (eV)', 'DLP Energy (eV)']

    #data_f['atoms'] = atoms * 10  #int(len(data_f)/len(atoms))
    data_f['atoms'] = int(len(data_f)/len(atoms))
    data_force_ = data_f.drop(columns=['atoms'])
    f_min_x = f_min_y = min(data_force_.quantile(0.002))
    f_max_x = f_max_y = max(data_force_.quantile(0.998))

    n_atoms_type = len(atoms_)
    if n_atoms_type == 1:
        n_columns = 2
        n_rows = 1
    elif n_atoms_type == 2:
        n_columns = 3
        n_rows = 1
    elif n_atoms_type == 3:
        n_columns = 2
        n_rows = 2

    elif n_atoms_type == 4:
        n_columns = 3
        n_rows = 2

    elif n_atoms_type == 5:
        n_columns = 3
        n_rows = 2

    elif n_atoms_type == 6:
        n_columns = 4
        n_rows = 2

    elif n_atoms_type == 7:
        n_columns = 4
        n_rows = 2

    elif n_atoms_type == 8:
        n_columns = 5
        n_rows = 2

    elif n_atoms_type == 9:
        n_columns = 5
        n_rows = 2

    elif n_atoms_type == 10:
        n_columns = 4
        n_rows = 3

    elif n_atoms_type == 11:
        n_columns = 4
        n_rows = 3

    fig = make_subplots(rows=n_rows,
                        cols=n_columns,
                        shared_xaxes=False,
                        vertical_spacing=0.17,
                        horizontal_spacing=0.06)

    colors = ['green', 'red', 'blue']
    n_atoms_ = 0
    f =  open('r2.txt', 'w')
    for n_row in range(1, n_rows + 1):
        for n_col in range(1, n_columns + 1):
            if n_row == 1 and n_col == 1:

                ##### Plot energy
                r2_e = str(
                    round(
                        r2_score(data_e['DFT Energy (eV)'],
                                 data_e['DLP Energy (eV)']), 2))
                f.write(f"Energy R2 {r2_e} \n")
                x_e = data_e['DFT Energy (eV)']
                y_e = data_e['DLP Energy (eV)']
                fig.append_trace(
                    go.Scatter(
                        x=x_e,
                        y=y_e,
                        mode="markers",
                        #name=legends[column_i],
                        #opacity=0.5,
                        #line=dict(color=colors[column_i]),
                        marker=dict(color=colors[0], size=3),
                        showlegend=False,
                    ),
                    row=1,
                    col=1,
                )
                e_d = min(x_e) - max(y_e)
                e_x_range = [min(y_e) + e_d * 0.1, max(y_e) - e_d * 0.1]
                e_min_x = min(e_x_range)
                e_max_x = max(e_x_range)
                fig.append_trace(
                    go.Scatter(
                        x=e_x_range,
                        y=e_x_range,
                        mode="lines",
                        #opacity=0.5,
                        #line=dict(color=colors[column_i]),
                        line=dict(dash='dot', width=1),
                        marker=dict(color='black', size=0),
                        showlegend=False,
                    ),
                    row=1,
                    col=1,
                )
                #plot_no += 1

            elif n_atoms_type > n_atoms_:
                if n_row == 1 and n_col == 2:
                    showlegend = True
                else:
                    showlegend = False
                ##### Plot forces
                data_force = data_f[data_f['atoms'] == atoms_[n_atoms_]].drop(
                    columns=['atoms'])

                for column_i, (column_x,
                               column_y) in enumerate(zip(x_name, y_name)):
                    y_pred = data_force[column_y].astype(float)
                    y_true = data_force[column_x].astype(float)
                    print(y_pred)

                    f_min = [min(y_pred), min(y_true)]
                    r2 = str(round(r2_score(y_true, y_pred), 2)) 
                    f.write(f"Force R2 {column_y} {atoms_[n_atoms_]} {r2} \n")
                    #print(len(y_true), r2)
                    fig.append_trace(
                        go.Scatter(
                            x=y_true,
                            y=y_pred,
                            mode="markers",
                            name=legends[column_i],
                            #opacity=0.5,
                            #line=dict(color=colors[column_i]),
                            marker=dict(color=colors[column_i], size=2),
                            showlegend=showlegend,
                        ),
                        row=n_row,
                        col=n_col,
                    )
                    f_d = f_min_y - f_max_y
                    f_x_range = [f_min_y + (f_d * 0.2), f_max_y - (f_d * 0.2)]
                    fig.append_trace(
                        go.Scatter(
                            x=f_x_range,
                            y=f_x_range,
                            mode="lines",
                            #opacity=0.5,
                            #line=dict(color=colors[column_i]),
                            line=dict(dash='dot', width=1),
                            marker=dict(color='black', size=0),
                            showlegend=False,
                        ),
                        row=n_row,
                        col=n_col,
                    )
                n_atoms_ += 1
    f.close()
    # Update layout
    font_size = 20
    x_axis_details = dict(
        #title='Materials',
        #tickmode='array',
        #tickvals=np.arange(int(f_x_range[0]), int(f_x_range[1])),
        #ticktext=directories_,
        gridcolor='lightgray',  # Set the gridline color
        griddash='dash',
        showline=True,  # Show the border line
        linecolor='black',  # Set the border line color
        linewidth=2,
        mirror=True,
        titlefont=dict(size=font_size + 2, color="black"),
        ticks="inside",
        tickwidth=2,
        ticklen=10,
        #dtick = 1,
        minor=dict(ticks="inside",
                   ticklen=5,
                   tickwidth=1,
                   tickcolor="black",
                   showgrid=False),
    )

    y_axis_details = dict(
        #tickmode='array',
        #tickvals=list(range(1, len(vac_) + 1)),
        gridcolor='lightgray',  # Set the gridline color
        griddash='dash',
        showline=True,  # Show the border line
        linecolor='black',  # Set the border line color
        linewidth=2,
        #title='VF Energy (eV)',
        titlefont=dict(size=font_size + 2, color="black"),
        mirror=True,
        ticks="inside",
        tickwidth=2,
        ticklen=10,
        #dtick = 1,
        minor=dict(ticks="inside",
                   ticklen=5,
                   tickwidth=1,
                   tickcolor="black",
                   showgrid=False),

        #automargin=True
        #anchor = 1
    )
    if n_rows == 1:
        legend_fix_y = 1
    else:
        legend_fix_y = (1 / n_rows) * 0.3
    fig.update_layout(
        #title_text='Subplots Example',
        xaxis=x_axis_details,
        xaxis2=x_axis_details,
        xaxis3=x_axis_details,
        xaxis4=x_axis_details,
        xaxis5=y_axis_details,
        xaxis6=y_axis_details,
        xaxis7=y_axis_details,
        xaxis8=y_axis_details,
        xaxis9=y_axis_details,
        xaxis10=y_axis_details,
        xaxis11=y_axis_details,
        xaxis12=y_axis_details,
        yaxis=y_axis_details,
        yaxis2=y_axis_details,
        yaxis3=y_axis_details,
        yaxis4=y_axis_details,
        yaxis5=y_axis_details,
        yaxis6=y_axis_details,
        yaxis7=y_axis_details,
        yaxis8=y_axis_details,
        yaxis9=y_axis_details,
        yaxis10=y_axis_details,
        yaxis11=y_axis_details,
        yaxis12=y_axis_details,
        showlegend=True,
        legend=dict(orientation='v',
                    yref='paper',
                    xref='paper',
                    yanchor="bottom",
                    xanchor="left",
                    x=(1 / n_columns) * (n_columns - 0.6),
                    y=legend_fix_y,
                    font_size=font_size + 3),
        plot_bgcolor='white',  # Set the background color to white
        paper_bgcolor='white',  # Set the paper color to white
        margin=dict(
            l=0,  #left margin
            r=0,  #right margin
            b=0,  #bottom margin
            t=0  #top margin
        ),
        #font_size=font_size-10,
        font=dict(size=font_size - 2, color="black"),
    )

    fig.update_layout(legend={'itemsizing': 'constant'})

    height = 300 * n_rows
    width = 300 * n_columns

    # Update x-axis and y-axis labels
    flabel = [
        '(a)', '(b)', '(c)', '(d)', '(e)', '(f)', '(g)', '(h)', '(i)', '(j)',
        '(k)', '(l)', '(m)', '(n)'
    ]
    n_flabel = 0
    n_atoms_ = 0
    for n_row in range(1, n_rows + 1):
        for n_col in range(1, n_columns + 1):
            if n_row == 1 and n_col == 1:
                fig.update_xaxes(title_text="E<sub>DFT</sub> (eV)",
                                 range=[e_min_x, e_max_x],
                                 title_standoff=0,
                                 row=1,
                                 col=1)
                fig.update_yaxes(title_text="E<sub>DLP</sub> (eV)",
                                 range=[e_min_x, e_max_x],
                                 title_standoff=10,
                                 row=1,
                                 col=1)

                fig.add_annotation(text=flabel[n_flabel],
                                   yanchor="top",
                                   xanchor="left",
                                   xref="paper",
                                   yref="paper",
                                   x=e_min_x,
                                   y=e_max_x,
                                   showarrow=False,
                                   font_size=font_size + 5,
                                   row=1,
                                   col=1)
            elif n_atoms_type > n_atoms_:
                fig.update_xaxes(title_text="F<sub>DFT</sub> (eV/Å)",
                                 range=[f_min_x, f_max_x],
                                 title_standoff=15,
                                 row=n_row,
                                 col=n_col)
                fig.update_yaxes(title_text="F<sub>DLP</sub> (eV/Å)",
                                 range=[f_min_x, f_max_x],
                                 title_standoff=0,
                                 row=n_row,
                                 col=n_col)

                fig.add_annotation(text=flabel[n_flabel],
                                   yanchor="top",
                                   xanchor="left",
                                   xref="paper",
                                   yref="paper",
                                   font_size=font_size + 5,
                                   x=f_min_x * 0.95,
                                   y=f_max_x * 0.95,
                                   showarrow=False,
                                   row=n_row,
                                   col=n_col)

                fig.add_annotation(
                    text=atoms_[n_atoms_],
                    #yanchor="top",
                    #xanchor="left",
                    xref="paper",
                    yref="paper",
                    font_size=font_size + 5,
                    x=f_max_x * 0.8,
                    y=f_min_x * 0.8,
                    showarrow=False,
                    row=n_row,
                    col=n_col)
                n_atoms_ += 1

            n_flabel += 1

    fig.write_html('force_accuracy.html')
    fig.write_image('force_accuracy.svg', scale=0.9, width=width, height=height)
    fig.write_image('force_accuracy.png', scale=0.9, width=width, height=height)
    #fig.show()
    return
